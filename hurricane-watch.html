<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hurricane Watch — One Page (No Key)</title>

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  :root{ color-scheme: dark; }
  body{ background:#0b1320; color:#e9eef8 }
  a{ color:#9fd2ff }
  header{ padding:1rem 0 }
  #map-wrap{ position:relative }
  #map{ height:56vh; border-radius:1rem; border:1px solid rgba(255,255,255,.1); overflow:hidden }
  .card{ background:#111a2e; border-color:rgba(255,255,255,.08) }
  .storm-pill{ font-weight:600 }
  .footer-note{ opacity:.75; font-size:.9rem }
  .spinner{ display:none }

  /* Readable titles */
  .storm-title{ color:#e9eef8; }

  /* Scan bar overlay */
  .scan-overlay{
    pointer-events:none;
    position:absolute; inset:0;
    overflow:hidden; border-radius:1rem; display:none;
  }
  .scan-stripe{
    position:absolute; top:0; bottom:0; width:120px;
    background: linear-gradient(to right,
      rgba(255,255,255,0) 0%,
      rgba(0,255,255,.10) 40%,
      rgba(0,255,255,.25) 50%,
      rgba(0,255,255,.10) 60%,
      rgba(255,255,255,0) 100%);
    filter: blur(1px); mix-blend-mode: screen;
    animation: scanX 4s linear infinite;
  }
  @keyframes scanX { 0%{transform:translateX(-140px)} 100%{transform:translateX(calc(100% + 140px))} }

  .legend {background:#111a2e;border:1px solid rgba(255,255,255,.1);padding:.5rem .75rem;border-radius:.5rem;font-size:.9rem}
  .legend span.badge{margin-right:.5rem}
</style>
</head>
<body class="container py-3">
  <header class="d-flex align-items-center justify-content-between">
    <h1 class="h4 m-0">Hurricane Watch</h1>
    <span class="spinner-border spinner-border-sm text-info spinner" id="spinner" role="status" aria-hidden="true"></span>
  </header>

  <p class="mb-3">Checks official NOAA/NHC data for any active tropical cyclones and plots their current positions. No API key required.</p>

  <div class="d-flex flex-wrap align-items-center gap-2 mb-2">
    <div class="form-check">
      <input class="form-check-input" type="checkbox" id="toggleProjections">
      <label class="form-check-label" for="toggleProjections">Show projections (forecast track & points)</label>
    </div>
    <div class="form-check">
      <input class="form-check-input" type="checkbox" id="toggleCone">
      <label class="form-check-label" for="toggleCone">Forecast cone (NHC)</label>
    </div>
    <div class="form-check">
      <input class="form-check-input" type="checkbox" id="toggleScan">
      <label class="form-check-label" for="toggleScan">Scanning overlay</label>
    </div>
    <div class="ms-auto legend">
      <span class="badge text-bg-danger">Hurricane</span>
      <span class="badge text-bg-info text-dark">Tropical Storm</span>
      <span class="badge text-bg-secondary">Tropical Depression</span>
      <span class="badge text-bg-light text-dark">Other</span>
      <span class="badge rounded-pill text-bg-primary">Track</span>
      <span class="badge rounded-pill text-bg-warning text-dark">Forecast pts</span>
      <span class="badge rounded-pill text-bg-light text-dark">Cone</span>
    </div>
  </div>

  <div id="status" class="alert alert-secondary py-2 px-3 small mb-3" role="alert">Loading latest storm positions…</div>

  <div id="map-wrap" class="mb-3">
    <div id="map"></div>
    <div id="scanOverlay" class="scan-overlay"><div class="scan-stripe"></div></div>
  </div>

  <div class="card mb-4">
    <div class="card-header">Active Systems</div>
    <div class="card-body">
      <div id="storms-list" class="row gy-2"></div>
    </div>
  </div>

  <p class="footer-note">
    Data: NOAA / NHC Tropical Weather Summary — Forecast Points (ID 5), Track (ID 6), Forecast Cone (ID 7). If loading fails, check the
    <a href="https://www.nhc.noaa.gov/cyclones/" target="_blank" rel="noopener">NHC Active Cyclones</a> page.
  </p>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
(async () => {
  const STATUS  = document.getElementById('status');
  const SPINNER = document.getElementById('spinner');
  const LIST    = document.getElementById('storms-list');
  const TOG_PROJ = document.getElementById('toggleProjections');
  const TOG_CONE = document.getElementById('toggleCone');
  const TOG_SCAN = document.getElementById('toggleScan');
  const SCAN = document.getElementById('scanOverlay');

  // NOAA NHC tropical summary service base
  const BASE = 'https://mapservices.weather.noaa.gov/tropical/rest/services/tropical/NHC_tropical_weather_summary/MapServer';
  const ENDPOINT_POINTS = BASE + '/5/query'; // Forecast Points
  const ENDPOINT_TRACK  = BASE + '/6/query'; // Forecast Track (polyline)
  const ENDPOINT_CONE   = BASE + '/7/query'; // Forecast Cone (polygon)

  const paramsPoints = {
    where: '1=1',
    outFields: 'stormname,stormtype,basin,advdate,advisnum,maxwind,mslp,ssnum,tcdvlp,tcspd,tcdir,lat,lon,validtime,fcstprd,tau',
    returnGeometry: 'true',
    f: 'geojson'
  };
  const paramsTrack = {
    where: '1=1',
    outFields: 'stormname,basin,validtime,fcstprd,tau',
    returnGeometry: 'true',
    f: 'geojson'
  };
  const paramsCone = {
    where: '1=1',
    outFields: 'stormname,stormtype,basin,advdate,advisnum,fcstprd,stormnum',
    returnGeometry: 'true',
    f: 'geojson'
  };

  // Leaflet map
  const map = L.map('map', { scrollWheelZoom: true }).setView([23, -60], 3);
  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' }).addTo(map);

  const layerCurrent  = L.layerGroup().addTo(map); // current markers
  const layerProjLine = L.layerGroup();            // forecast track polylines
  const layerProjPts  = L.layerGroup();            // forecast future points
  const layerCone     = L.layerGroup();            // forecast cone polygons

  // UI toggles
  TOG_PROJ.addEventListener('change', () => {
    if (TOG_PROJ.checked) { map.addLayer(layerProjLine); map.addLayer(layerProjPts); }
    else { map.removeLayer(layerProjLine); map.removeLayer(layerProjPts); }
  });
  TOG_CONE.addEventListener('change', () => {
    if (TOG_CONE.checked) map.addLayer(layerCone); else map.removeLayer(layerCone);
  });
  TOG_SCAN.addEventListener('change', () => {
    SCAN.style.display = TOG_SCAN.checked ? 'block' : 'none';
  });

  function stormBadge(type) {
    const t = (type || '').toLowerCase();
    if (t.includes('hurricane')) return '<span class="badge text-bg-danger storm-pill">Hurricane</span>';
    if (t.includes('tropical storm')) return '<span class="badge text-bg-info text-dark storm-pill">Tropical Storm</span>';
    if (t.includes('tropical depression')) return '<span class="badge text-bg-secondary storm-pill">Tropical Depression</span>';
    return `<span class="badge text-bg-light text-dark storm-pill">${type || 'System'}</span>`;
  }
  function markerStyle(type) {
    const t = (type || '').toLowerCase();
    if (t.includes('hurricane')) return { radius: 8, weight: 2 };
    if (t.includes('tropical storm')) return { radius: 7, weight: 2 };
    if (t.includes('tropical depression')) return { radius: 6, weight: 2 };
    return { radius: 6, weight: 1 };
  }
  const trackStyle = { weight: 2, opacity: 0.9 }; // forecast line
  const projPtStyle = { radius: 4, weight: 1 };   // forecast point marker
  const coneStyle = { color: '#111827', weight: 1, fillColor: '#ffffff', fillOpacity: 0.20 }; // white translucent cone

  function round(n, d=1){ return (typeof n==='number') ? Number(n.toFixed(d)) : n; }
  async function fetchGeoJSON(url, paramsObj){
    const res = await fetch(url + '?' + new URLSearchParams(paramsObj).toString());
    if (!res.ok) throw new Error('Network response was not ok: ' + res.status);
    return res.json();
  }

  try{
    SPINNER.style.display = 'inline-block';

    // 1) Grab ALL forecast points first; we derive "current" and "future"
    const geoAllPts = await fetchGeoJSON(ENDPOINT_POINTS, paramsPoints);

    // Build "current point per storm" (prefer fcstprd===0, else tau===0, else latest)
    const byStorm = new Map();
    for (const f of (geoAllPts.features || [])) {
      const p = f.properties || {};
      const key = `${p.stormname || 'Unknown'}|${p.basin || ''}`;
      const score = (p.fcstprd === 0 ? 3 : (p.tau === 0 ? 2 : 1));
      const prev = byStorm.get(key);
      const prevScore = prev?.score ?? 0;
      if (score > prevScore) byStorm.set(key, { f, score });
      else if (score === prevScore) {
        const a = (p.validtime || p.advdate || ''), b = (prev?.f.properties.validtime || prev?.f.properties.advdate || '');
        if (a > b) byStorm.set(key, { f, score });
      }
    }
    const currentFeatures = Array.from(byStorm.values()).map(x => x.f);

    // Prepare future points (tau>0 or fcstprd>0)
    const futureByStorm = new Map();
    for (const f of (geoAllPts.features || [])) {
      const p = f.properties || {};
      const key = `${p.stormname || 'Unknown'}|${p.basin || ''}`;
      const tau = (typeof p.tau === 'number') ? p.tau : (typeof p.fcstprd === 'number' ? p.fcstprd : null);
      if (tau && tau > 0) {
        if (!futureByStorm.has(key)) futureByStorm.set(key, []);
        futureByStorm.get(key).push(f);
      }
    }

    // 2) Fetch tracks & cones (optional layers; we’ll render but keep hidden until toggled)
    const [geoTrack, geoCone] = await Promise.all([
      fetchGeoJSON(ENDPOINT_TRACK, paramsTrack),
      fetchGeoJSON(ENDPOINT_CONE, paramsCone)
    ]);

    // Render current markers & list
    layerCurrent.clearLayers();
    layerProjLine.clearLayers();
    layerProjPts.clearLayers();
    layerCone.clearLayers();
    LIST.innerHTML = '';
    let bounds = [];

    if (currentFeatures.length === 0) {
      STATUS.className = 'alert alert-success py-2 px-3 small';
      STATUS.textContent = 'No active tropical cyclones at this time.';
      map.setView([23, -60], 3);
      LIST.innerHTML = '<p class="mb-0">None.</p>';
    } else {
      STATUS.className = 'alert alert-warning py-2 px-3 small';
      STATUS.textContent = `Active systems detected: ${currentFeatures.length}`;

      for (const f of currentFeatures) {
        const p = f.properties || {};
        const g = f.geometry || {};
        const coords = Array.isArray(g.coordinates) ? g.coordinates : [null, null];
        const lon = (typeof p.lon === 'number') ? p.lon : coords[0];
        const lat = (typeof p.lat === 'number') ? p.lat : coords[1];

        const name = p.stormname || 'Unnamed';
        const type = p.stormtype || p.tcdvlp || 'Tropical Cyclone';
        const badge = stormBadge(type);
        const cat = (typeof p.ssnum === 'number' && p.ssnum >= 1) ? `Category ${p.ssnum}` : (p.maxwind ? `${p.maxwind} kt` : '');
        const motion = (p.tcdir != null && p.tcspd != null) ? ` · Motion ${round(p.tcdir)}° @ ${round(p.tcspd)} kt` : '';
        const when = p.advisnum ? `Advisory ${p.advisnum}` : '';
        const time = p.validtime || p.advdate || '';
        const coordTxt = (typeof lat==='number' && typeof lon==='number') ? ` · ${round(lat,2)}, ${round(lon,2)}` : '';

        if (typeof lat === 'number' && typeof lon === 'number') {
          const mrk = L.circleMarker([lat, lon], markerStyle(type))
            .bindPopup(`
              <div><strong>${name}</strong> ${badge}</div>
              <div>${p.basin ? 'Basin: ' + p.basin : ''}</div>
              <div>${cat}${motion}</div>
              <div>${when}${time ? ' · ' + time : ''}</div>
              <div>Lat/Lon: ${round(lat,2)}, ${round(lon,2)}</div>
            `);
          mrk.addTo(layerCurrent);
          bounds.push([lat, lon]);
        }

        // List card
        const col = document.createElement('div');
        col.className = 'col-12 col-md-6';
        col.innerHTML = `
          <div class="p-3 border rounded">
            <div class="d-flex justify-content-between align-items-start">
              <div>
                <div class="h5 mb-1 storm-title">${name}</div>
                <div class="mb-1">${badge}</div>
                <div class="small text-white-50">
                  ${p.basin || ''} · ${cat}${motion}${coordTxt}
                </div>
                <div class="small text-white-50">${when}${time ? ' · ' + time : ''}</div>
              </div>
              <div class="d-flex flex-column gap-1">
                <button class="btn btn-sm btn-outline-info" ${ (typeof lat==='number' && typeof lon==='number') ? '' : 'disabled' }>
                  Zoom
                </button>
                <button class="btn btn-sm btn-outline-primary projBtn">Projections</button>
                <button class="btn btn-sm btn-outline-light coneBtn">Cone</button>
              </div>
            </div>
          </div>`;
        const [zoomBtn, projBtn, coneBtn] = col.querySelectorAll('button');
        zoomBtn?.addEventListener('click', () => {
          if (typeof lat==='number' && typeof lon==='number') map.setView([lat, lon], 6, { animate: true });
        });
        projBtn?.addEventListener('click', () => {
          TOG_PROJ.checked = true; TOG_PROJ.dispatchEvent(new Event('change'));
          if (typeof lat==='number' && typeof lon==='number') map.setView([lat, lon], 6, { animate: true });
        });
        coneBtn?.addEventListener('click', () => {
          TOG_CONE.checked = true; TOG_CONE.dispatchEvent(new Event('change'));
          if (typeof lat==='number' && typeof lon==='number') map.setView([lat, lon], 6, { animate: true });
        });
        LIST.appendChild(col);
      }

      // Render forecasts (projections)
      // Track: lines grouped per storm, sorted by tau/time
      const linesByStorm = new Map();
      for (const f of (geoTrack.features || [])) {
        const p = f.properties || {};
        const key = `${p.stormname || 'Unknown'}|${p.basin || ''}`;
        if (!linesByStorm.has(key)) linesByStorm.set(key, []);
        linesByStorm.get(key).push(f);
      }
      for (const arr of linesByStorm.values()) {
        // Each feature is a polyline segment; draw them as one multiline
        arr.forEach(seg => {
          const coords = seg.geometry?.coordinates || [];
          const latlngs = coords.map(c => [c[1], c[0]]).filter(([la,lo]) => Number.isFinite(la) && Number.isFinite(lo));
          if (latlngs.length >= 2) L.polyline(latlngs, trackStyle).addTo(layerProjLine);
        });
      }
      // Future forecast points
      for (const [key, futurePts] of futureByStorm.entries()) {
        futurePts.sort((a,b) => {
          const pa=a.properties||{}, pb=b.properties||{};
          const ta = (typeof pa.tau==='number') ? pa.tau : (typeof pa.fcstprd==='number'?pa.fcstprd:999999);
          const tb = (typeof pb.tau==='number') ? pb.tau : (typeof pb.fcstprd==='number'?pb.fcstprd:999999);
          if (ta!==tb) return ta-tb;
          const sa=(pa.validtime||pa.advdate||''), sb=(pb.validtime||pb.advdate||'');
          return sa.localeCompare(sb);
        });
        for (const fp of futurePts) {
          const pp=fp.properties||{}, gg=fp.geometry||{}, c2=Array.isArray(gg.coordinates)?gg.coordinates:[null,null];
          const lon2=(typeof pp.lon==='number')?pp.lon:c2[0];
          const lat2=(typeof pp.lat==='number')?pp.lat:c2[1];
          if (Number.isFinite(lat2)&&Number.isFinite(lon2)) {
            L.circleMarker([lat2,lon2], projPtStyle)
              .bindTooltip(`${pp.stormname || 'Storm'} • ${pp.validtime || ('+'+(pp.tau ?? pp.fcstprd)+'h')}`, {direction:'top'})
              .addTo(layerProjPts);
          }
        }
      }

      // Render forecast cones (polygons)
      const cones = geoCone.features || [];
      for (const poly of cones) {
        const props = poly.properties || {};
        // many cone polygons come as MultiPolygon; normalize to rings
        const geom = poly.geometry || {};
        const toLatLngs = (coords) => coords.map(ring => ring.map(([x,y]) => [y,x]));
        if (geom.type === 'Polygon' && Array.isArray(geom.coordinates)) {
          L.polygon(toLatLngs(geom.coordinates), coneStyle).addTo(layerCone)
            .bindTooltip(`${props.stormname || 'Storm'} • Cone`);
        } else if (geom.type === 'MultiPolygon' && Array.isArray(geom.coordinates)) {
          geom.coordinates.forEach(pol => {
            L.polygon(toLatLngs(pol), coneStyle).addTo(layerCone)
              .bindTooltip(`${props.stormname || 'Storm'} • Cone`);
          });
        }
      }
      // Keep cone layer hidden until toggled
      if (!TOG_CONE.checked) map.removeLayer(layerCone);

      // Fit bounds to current markers
      if (bounds.length) map.fitBounds(L.latLngBounds(bounds).pad(0.3));
    }
  } catch (err) {
    console.error(err);
    STATUS.className = 'alert alert-danger py-2 px-3 small';
    STATUS.innerHTML = `Couldn’t load NOAA data right now. Try again later or see the <a href="https://www.nhc.noaa.gov/cyclones/" target="_blank" rel="noopener">NHC Active Cyclones</a> page.`;
  } finally {
    SPINNER.style.display = 'none';
  }
})();
</script>
</body>
</html>
