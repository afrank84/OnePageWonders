<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Kanji Sketch ‚Üí Meaning</title>

<!-- Bootstrap 5.3.3 (your preferred CDN) -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

<!-- Tesseract.js -->
<script src="https://unpkg.com/tesseract.js@v5.0.5/dist/tesseract.min.js"></script>

<style>
  :root{
    --bg:#0b0e14; --card:#111624; --text:#e8e8e8; --muted:#9aa6b2; --accent:#8ab4ff;
  }
  body{ background:var(--bg); color:var(--text); }
  .card{ background:var(--card); border:1px solid #1c2333; }
  a{ color:var(--accent); }
  canvas{ background:#fff; border-radius:12px; box-shadow:0 0 0 1px #1c2333 inset; touch-action:none; }
  .toolbtn{ min-width:9rem; }
  .stroke-dot{ width:8px; height:8px; background:#000; border-radius:50%; position:absolute; display:none; }
  .progress{ height:.5rem; }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  .kanji-big{ font-size:64px; line-height:1; }
  .hint{ color:var(--muted); font-size:.9rem; }
  .badge-soft{ background:rgba(255,255,255,.08); border:1px solid #1c2333; }
</style>
</head>
<body>
<div class="container py-4">
  <h1 class="h3 mb-3">‚úçÔ∏è Draw Japanese ‚Üí Get Meaning</h1>
  <p class="hint mb-4">Draw one character in the canvas (big & bold strokes). Click <strong>Recognize</strong>, then meanings/readings will appear. If OCR misses, paste the character below and use <strong>Lookup</strong>.</p>

  <div class="row g-4">
    <div class="col-lg-6">
      <div class="card p-3">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <div class="d-flex gap-2 align-items-center">
            <label class="form-label me-2 mb-0">Pen</label>
            <input id="size" type="range" min="6" max="40" value="18" class="form-range" style="width:200px">
            <span class="hint" id="sizeOut">18 px</span>
          </div>
          <div class="d-flex gap-2">
            <button id="undo" class="btn btn-outline-light btn-sm toolbtn">Undo Stroke</button>
            <button id="clear" class="btn btn-outline-light btn-sm toolbtn">Clear</button>
          </div>
        </div>
        <canvas id="pad" width="600" height="600"></canvas>
        <div class="d-flex gap-2 mt-3">
          <button id="recognize" class="btn btn-primary toolbtn">Recognize (OCR)</button>
          <button id="export" class="btn btn-secondary">Save PNG</button>
          <div class="ms-auto d-flex align-items-center gap-2">
            <div class="progress flex-grow-1" style="width:200px"><div class="progress-bar" id="prog" style="width:0%"></div></div>
            <span id="progLabel" class="hint mono">0%</span>
          </div>
        </div>
        <p class="hint mt-2 mb-0">Tips: one character at a time ‚Ä¢ block style ‚Ä¢ fill most of canvas ‚Ä¢ steady strokes.</p>
      </div>
    </div>

    <div class="col-lg-6">
      <div class="card p-3 mb-3">
        <div class="d-flex gap-2 align-items-end">
          <div class="flex-grow-1">
            <label class="form-label">Or paste / type a character to look up</label>
            <input id="manualChar" maxlength="8" class="form-control" placeholder="‰æã: Áå´ or Â≠¶ / „Å≤„Çâ„Åå„Å™ / „Ç´„Çø„Ç´„Éä">
          </div>
          <button id="lookup" class="btn btn-success toolbtn">Lookup</button>
        </div>
        <div class="d-flex gap-2 mt-2">
          <a class="btn btn-outline-info btn-sm" href="https://jisho.org/#handwriting" target="_blank" rel="noopener">Open Jisho Handwriting</a>
          <span class="hint">Use if OCR struggles; then paste the result here.</span>
        </div>
      </div>

      <div class="card p-3">
        <div class="mb-2">
          <div class="hint">OCR Result (raw):</div>
          <div id="rawText" class="mono"></div>
        </div>
        <hr class="text-secondary">
        <div id="results" class="vstack gap-3"></div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const pad = document.getElementById('pad');
  const ctx = pad.getContext('2d');
  const size = document.getElementById('size');
  const sizeOut = document.getElementById('sizeOut');
  const undoBtn = document.getElementById('undo');
  const clearBtn = document.getElementById('clear');
  const recognizeBtn = document.getElementById('recognize');
  const exportBtn = document.getElementById('export');
  const rawText = document.getElementById('rawText');
  const results = document.getElementById('results');
  const prog = document.getElementById('prog');
  const progLabel = document.getElementById('progLabel');
  const manualChar = document.getElementById('manualChar');
  const lookupBtn = document.getElementById('lookup');

  // Drawing state
  let drawing = false;
  let strokes = [];      // array of paths; each path = array of points [{x,y}]
  let currentPath = [];
  let penSize = +size.value;

  function resetCanvas() {
    ctx.fillStyle = "#fff";
    ctx.fillRect(0,0,pad.width,pad.height);
  }
  resetCanvas();

  size.addEventListener('input', () => {
    penSize = +size.value;
    sizeOut.textContent = penSize + " px";
  });

  // Pointer utils
  const getXY = (e) => {
    const r = pad.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - r.left;
    const y = (e.touches ? e.touches[0].clientY : e.clientY) - r.top;
    return {x: Math.max(0, Math.min(pad.width,  x * (pad.width  / r.width))),
            y: Math.max(0, Math.min(pad.height, y * (pad.height / r.height)))};
  };

  function redraw() {
    resetCanvas();
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = "#000";
    ctx.fillStyle = "#000";
    for (const path of strokes) {
      ctx.lineWidth = path.size || penSize;
      ctx.beginPath();
      for (let i=0;i<path.points.length;i++){
        const p = path.points[i];
        if (i===0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
      // Dot for single taps
      if (path.points.length===1){
        const p=path.points[0];
        ctx.beginPath(); ctx.arc(p.x,p.y,(path.size||penSize)/2,0,Math.PI*2); ctx.fill();
      }
    }
  }

  function startDraw(e){
    drawing = true;
    currentPath = {size: penSize, points: []};
    const p = getXY(e);
    currentPath.points.push(p);
    strokes.push(currentPath);
    redraw();
    e.preventDefault();
  }
  function moveDraw(e){
    if (!drawing) return;
    const p = getXY(e);
    currentPath.points.push(p);
    redraw();
    e.preventDefault();
  }
  function endDraw(e){
    drawing = false;
    currentPath = [];
    e && e.preventDefault();
  }

  // Events
  pad.addEventListener('pointerdown', startDraw);
  pad.addEventListener('pointermove', moveDraw);
  window.addEventListener('pointerup', endDraw);
  pad.addEventListener('touchstart', startDraw, {passive:false});
  pad.addEventListener('touchmove', moveDraw, {passive:false});
  window.addEventListener('touchend', endDraw, {passive:false});

  undoBtn.onclick = () => { strokes.pop(); redraw(); };
  clearBtn.onclick = () => { strokes = []; redraw(); };

  // Crop to bounding box so OCR doesn't see big whitespace
  function cropToContent(canvas) {
    const w = canvas.width, h = canvas.height;
    const src = canvas.getContext('2d').getImageData(0,0,w,h);
    const d = src.data;
    let minX=w, minY=h, maxX=0, maxY=0;
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i=(y*w+x)*4;
        // pixel is non-white?
        if (!(d[i]===255 && d[i+1]===255 && d[i+2]===255)){
          if (x<minX) minX=x;
          if (y<minY) minY=y;
          if (x>maxX) maxX=x;
          if (y>maxY) maxY=y;
        }
      }
    }
    // If nothing drawn, return original
    if (minX>maxX || minY>maxY) return canvas;

    // Add padding
    const padPx = 20;
    minX = Math.max(0, minX - padPx);
    minY = Math.max(0, minY - padPx);
    maxX = Math.min(w-1, maxX + padPx);
    maxY = Math.min(h-1, maxY + padPx);

    const cw = maxX - minX + 1, ch = maxY - minY + 1;
    const out = document.createElement('canvas');
    out.width = out.height = Math.max(cw, ch); // make square
    const octx = out.getContext('2d');
    octx.fillStyle="#fff"; octx.fillRect(0,0,out.width,out.height);
    // center cropped block in square
    const dx = (out.width - cw) / 2, dy = (out.height - ch) / 2;
    octx.drawImage(canvas, minX, minY, cw, ch, dx, dy, cw, ch);
    return out;
  }

  function setProgress(pct, label){
    prog.style.width = pct + "%";
    progLabel.textContent = Math.round(pct) + "%";
  }

  async function recognizeCanvas() {
    if (strokes.length===0){
      alert("Draw a character first üôÇ");
      return;
    }
    recognizeBtn.disabled = true; setProgress(5,""); rawText.textContent = "";
    try{
      // Create a cropped image for better OCR
      const cropped = cropToContent(pad);
      // Do OCR (Japanese)
      const { data } = await Tesseract.recognize(cropped, 'jpn', {
        logger: m => {
          if (m.status === 'loading tesseract core') setProgress(10);
          if (m.status === 'initializing tesseract') setProgress(20);
          if (m.status === 'loading language traineddata') setProgress(30);
          if (m.status === 'initializing api') setProgress(40);
          if (m.status === 'recognizing text') setProgress(40 + (m.progress||0)*60);
        },
        langPath: 'https://tessdata.projectnaptha.com/4.0.0_best/'
      });
      const text = (data.text || "").replace(/\s+/g, "");
      rawText.textContent = text || "(no text)";
      setProgress(100,"");
      // Extract CJK (kanji) + kana
      const chars = [...new Set([...(text||"")])].filter(ch =>
        /[\u3400-\u9FFF\uF900-\uFAFF\u3040-\u309F\u30A0-\u30FF]/.test(ch)
      );
      if (chars.length===0){ showMessage("No JP characters detected. Try thicker strokes & fill the canvas."); return; }
      results.innerHTML = "";
      for (const ch of chars){ await lookupKanji(ch); }
    } catch(err){
      console.error(err);
      showMessage("OCR failed. Try again or use 'Open Jisho Handwriting' and paste the result.");
    } finally {
      recognizeBtn.disabled = false;
      setTimeout(()=>setProgress(0,""), 600);
    }
  }

  function showMessage(msg){
    const div = document.createElement('div');
    div.className = "alert alert-warning";
    div.textContent = msg;
    results.prepend(div);
  }

  async function lookupKanji(ch){
    // If kana, just show a small card (kanji endpoint won‚Äôt have entries for pure kana)
    const isKana = /[\u3040-\u309F\u30A0-\u30FF]/.test(ch);
    if (isKana){
      const card = document.createElement('div');
      card.className = "card p-3";
      card.innerHTML = `
        <div class="d-flex align-items-center gap-3">
          <div class="kanji-big">${ch}</div>
          <div>
            <div class="hint mb-1">Kana</div>
            <div>Copy/paste into a dictionary (e.g. Jisho) for words and meanings.</div>
            <a class="small" target="_blank" rel="noopener" href="https://jisho.org/search/${encodeURIComponent(ch)}">Search on Jisho</a>
          </div>
        </div>`;
      results.appendChild(card);
      return;
    }
    // Kanji details from kanjiapi.dev
    try{
      const base = 'https://kanjiapi.dev/v1';
      const k = await fetch(`${base}/kanji/${encodeURIComponent(ch)}`).then(r=>r.json());
      const words = await fetch(`${base}/words/${encodeURIComponent(ch)}`).then(r=>r.json()).catch(()=>[]);
      const topWords = (Array.isArray(words)?words:[]).slice(0,5).map(w=>{
        const v = w.variants?.[0] || {};
        const gloss = (w.meanings?.[0]?.glosses?.[0]) || "";
        return `<span class="badge badge-soft me-2 mb-2">${v.written||""}„Äê${v.pronounced||""}„Äë<span class="text-secondary ms-1">${gloss}</span></span>`;
      }).join("");

      const card = document.createElement('div');
      card.className = "card p-3";
      card.innerHTML = `
        <div class="d-flex align-items-start gap-3">
          <div class="kanji-big">${k.kanji || ch}</div>
          <div class="flex-grow-1">
            <div class="mb-1"><strong>Meanings:</strong> ${(k.meanings||[]).join(", ") || "‚Äî"}</div>
            <div class="mb-1"><strong>On:</strong> ${(k.on_readings||[]).join("„ÄÅ") || "‚Äî"}</div>
            <div class="mb-1"><strong>Kun:</strong> ${(k.kun_readings||[]).join("„ÄÅ") || "‚Äî"}</div>
            <div class="hint">Strokes: ${k.stroke_count ?? "‚Äî"} ‚Ä¢ JLPT: ${k.jlpt ?? "‚Äî"} ‚Ä¢ Grade: ${k.grade ?? "‚Äî"} ‚Ä¢ Unicode: ${k.unicode ?? "‚Äî"}</div>
            <div class="mt-2">
              <a target="_blank" rel="noopener" href="https://jisho.org/search/${encodeURIComponent(ch)}%20%23kanji">More on Jisho</a>
            </div>
          </div>
        </div>
        ${topWords ? `<hr><div><strong>Example words:</strong><div class="mt-2">${topWords}</div></div>` : ``}
      `;
      results.appendChild(card);
    }catch(err){
      console.error(err);
      showMessage(`Lookup failed for ${ch}. Try again or search on Jisho.`);
    }
  }

  recognizeBtn.onclick = recognizeCanvas;
  lookupBtn.onclick = async () => {
    const s = (manualChar.value || "").trim();
    if (!s) return;
    results.innerHTML = ""; rawText.textContent = s;
    for (const ch of [...new Set([...s])]){
      if (/[\u3400-\u9FFF\uF900-\uFAFF\u3040-\u309F\u30A0-\u30FF]/.test(ch)){
        await lookupKanji(ch);
      }
    }
  };

  exportBtn.onclick = () => {
    const a = document.createElement('a');
    a.download = 'kanji.png';
    a.href = pad.toDataURL('image/png');
    a.click();
  };
})();
</script>
</body>
</html>
